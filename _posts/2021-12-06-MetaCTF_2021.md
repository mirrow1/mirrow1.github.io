---
layout: post
title: MetaCTF 2021 - "Unbreakable Encryption (Crypto)" & "Looking Inwards (Web)"
---

<h2>Overview</h2>

MetaCTF 2021 was a 48-hour live Capture The Flag competition held between 3-5th December. Our team scored 5625 pts placing us at 160th place (top 10%) out of 1932 teams.

![image](https://user-images.githubusercontent.com/44827973/144810240-b34e0fe3-3c95-4f91-b142-a3a0749e9770.png)

In this post I want to detail the solutions to two problems I found particularly interesting. Finally I want to summarize some thoughts and takeaways I got from doing this CTF.

<!--more-->

<h3>1. Unbreakable Encryption (Crypto Challenge) (484 solves)</h3>

<strong>Challenge description:</strong>
```
There is a form of truly unbreakable encryption: the one time pad. Nobody, not Russia, not China, and not even Steve, who lives in
his mom's basement and hacks governments for fun, can decrypt anything using this cipher... as long as it's used correctly. In this
scheme, a truly random string as long as the plaintext is chosen, and the ciphertext is computed as the bitwise XOR of the
plaintext and the key. However, if the key is reused even once, it can be cracked. We've intercepted some messages between some
criminals, and we're hoping you could crack the one time pad they used. We're pretty sure they reused it, so you should be able to
crack it…

Ciphertext 1: 4fd098298db95b7f1bc205b0a6d8ac15f1f821d72fbfa979d1c2148a24feaafdee8d3108e8ce29c3ce1291
Plaintext 1: hey let's rob the bank at midnight tonight!
Ciphertext 2: 41d9806ec1b55c78258703be87ac9e06edb7369133b1d67ac0960d8632cfb7f2e7974e0ff3c536c1871b
```

I went into this challenge not knowing anything about Bitwise XOR ("eXclusive OR"), but the challenge description and a bit of research provides enough information.

From Wikipedia:

```
A bitwise XOR is a binary operation that takes two bit patterns of equal length and performs the logical exclusive OR
operation on each pair of corresponding bits.
The result in each position is 1 if only one of the bits is 1, but will be 0 if both are 0 or both are 1.
In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same.
```

Here's an example. Say we want to do the bitwise XOR operation on the first character of ciphertext 1 against the first character of plaintext 1.

Because the operation operates on the individual bits, we convert the characters to binary.

4f (hex) = 01001111 (binary)

h (ASCII) = 01101000 (binary)

Then we do the XOR operation on each corresponding pair of bits: if the pair is different, resultant bit is 1; if the pair is the same, resultant bit is 0.

![image](https://user-images.githubusercontent.com/44827973/144806787-17cd2b9c-c63b-4e36-8c35-c55fb438eed8.png)

The result we have is `00100111` which is the first byte of our key.
Then we need to do the same thing for the rest of the characters of the ciphertext and the plaintext, giving us the full key.
Once we have the full key, we apply the same bitwise XOR operation of the key against the second ciphertext to get the flag (the reverse of XOR is XOR).
As the challenge description says, the key is reused which allows us to crack ciphertext 2.

Here's a python script I wrote to do it for me.

<details>
  <summary>Click me</summary>
  
  ```python3
#!/usr/bin/env python3
import math
import re

'''
Steps:

The given ciphertext is in hex, and the plaintext is in ascii obviously.

1. convert the ciphertext to decimals
2. convert the plaintext chars to decimals
3. do bitwise exclusive OR operation to find the characters making up the key
4. use the key to perform another exclusive OR operation against the second ciphertext (XOR is reversible) to get the flag

'''

# 1. convert the ciphertext to decimal list

s = "4fd098298db95b7f1bc205b0a6d8ac15f1f821d72fbfa979d1c2148a24feaafdee8d3108e8ce29c3ce1291"

# first separate the ciphertext to individual hex characters
hex_chars = re.findall('..',s)

cipher_dec = []

# then convert the hex characters to decimals, stored in cipher_dec
for i in range(len(hex_chars)):
	cipher_dec.append(int(hex_chars[i],16))

# 2. convert the plaintext to decimal list

string = "hey let's rob the bank at midnight tonight!"

plaintext_dec = []

for i in string:
	plaintext_dec.append(ord(i))

# 3. do bitwise exclusive OR operation to find the characters making up the key

key = []

# the bin(cipher_dec[i] ^ plaintext_dec[i]) function returns binary characters. We need to change back to decimal
for i in range(0,43):

	key.append(bin(cipher_dec[i] ^ plaintext_dec[i]))

# changing back to decimal. Then we have the key
key_dec = []

for i in key:
	key_dec.append(int(i,2))

# 4. use the key to perform another exclusive OR operation against the second ciphertext (XOR is reversible) to get the flag

# the second ciphertext which we are trying to decrypt
s2 = "41d9806ec1b55c78258703be87ac9e06edb7369133b1d67ac0960d8632cfb7f2e7974e0ff3c536c1871b"

# again split into hex characters
hex_chars2 = re.findall('..',s2)

#convert from hex to decimal
cipher_dec2 = []

for i in range(len(hex_chars2)):
	cipher_dec2.append(int(hex_chars2[i],16))

# do bitwise XOR for each character in the key with each character in the second ciphertext
unciphered = []

for i in range(0,42):
	unciphered.append(bin(key_dec[i] ^ cipher_dec2[i]))

text = []

# (chr(int(i,2))) converts binary > decimal > ascii chars
for i in unciphered:
	text.append(chr(int(i,2)))

flag = "".join(text)

print(flag)

  ```
</details>

It prints `flag is MetaCTF{you're_better_than_steve!}`

<strong>Flag: MetaCTF{you're_better_than_steve!}</strong>

